/*
Реализуйте и экспортируйте по умолчанию асинхронную функцию, которая следит за
изменением файла с заданной периодичностью. Функция должна возвращать
идентификатор таймера, запущенного внутри.
Если файл был изменён со времени предыдущей проверки, то необходимо вызвать
колбек. Если во время анализа файла (через fs.stat) произошла ошибка, то нужно
остановить таймер и вызвать колбек, передав туда ошибку.
Отслеживание изменний файла должно начинаться с момента вызова функции.
Параметры функции:
- Путь до файла, который нужно отслеживать
- Период отслеживания
- Колбек, принимающий аргументом ошибку

Пример:
const id = watch(filepath, 500, (err) => {
  console.log('Wow!');
});

setTimeout(() => fs.appendFileSync(filepath, 'ehu'), 700);
// остановить отслеживание через 5 секунд
setTimeout(() => clearInterval(id), 5000);

Функция должна постоянно отслеживать изменения файла и вызывать колбек, если
обнаружено изменение файла. После вызова колбека, функция должна продолжать
отслеживать измения. Отслеживание останавливают сами тесты, для этого ваша
функция должна возвращать id таймера.

stats.mtimeMs — время последнего изменения
Date.now() — текущая дата
*/

import fs from 'fs';

const watcher = (filepath, period, cb) => {
  let checkedTime = Date.now();

  const check = (id) => {
    fs.stat(filepath, (err, stats) => {
      if (err) {
        clearInterval(id);
        cb(err);
        return;
      }

      const { mtimeMs } = stats;

      if (mtimeMs > checkedTime) {
        cb(null);
        checkedTime = mtimeMs;
      }
    });
  };

  const id = setInterval(() => check(id), period);
  return id;
};

export default watcher;
